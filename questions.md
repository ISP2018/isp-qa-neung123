# Questions

**Q1:** Why you should not return `Null`?

---
**Q2:** When should I use assert and when should I use exception?

---
**Q3:** What you should follow while writing unit tests?

- [ ] Don't write code until you have written a failing unit test.
- [ ] Write code first and write unit tests cover the possible things that can make the code fail. 
- [ ] You cannot write more code than enough to pass the test that is failing.
- [ ] Don't create more tests than necessary to failing.

---
**Q4:** Why should you "Present useful error messages"?

---
**Q5:** After you have finished your tasks about GitHub's issue number 32. 
How to automatically close issue number 32 when you push a commit to GitHub?


# Answers
**A1:** When we return null, we are essentially creating work for ourselves and 
foisting problems upon our callers. If you are not returning null, you do not 
have to check for it and hence your code does not need to follow a different path 
based on the return value. 

    `List<Employee> employees = getEmployees(); 
    if (employees != null) {  
        for(Employee e : employees) {    
            totalPay += e.getPay(); 
        } 
    }`
    
Right now, `getEmployees` can return null, but we change `getEmployee` 
so that it returns an empty list, we can clean up the code to:

    `List<Employee> employees = getEmployees(); 
     for(Employee e : employees) {    
        totalPay += e.getPay(); 
     }`
     
> Ref: Robert C. Martin "The Clean Code" - Don’t Return Null

---
**A2:** Assertions should only be used to verify conditions that should be logically 
impossible to be false (read: sanity checks). These conditions should only be based 
on inputs generated by your own code. Any checks based on external inputs should use exceptions.
        
> Ref: Bil Lewis ["Assertations vs. Exceptions"](http://www.drdobbs.com/jvm/assertations-vs-exceptions/228701655)
---
**A3:**
- [x] Don't write code until you have written a failing unit test.
- [ ] Write code first and write unit tests cover the possible things that can make the code fail. 
- [x] You cannot write more code than enough to pass the test that is failing.
- [x] Don't create more tests than necessary to failing.

The Three Laws of TDD said that

* First Law: You may not write production code until you have written a failing unit test.
* Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
* Third Law: You may not write more production code than is sufficient to pass the currently failing test

> Ref: Robert C. Martin "The Clean Code" - unit tests
---
**A4:** When such an error occurs, the most common solution is to  have the application log details of the error.
But your program throws something that clueless about the error user (or even developer) will not know what went wrong.
So, you should provide an easy way to ﬁnd the details of errors. Present as much supporting detail as you can about a problem when it occurs.

> Ref: Andy Hunt "Practices of an Agile Developer" - PAD 37
---
**A5:** `git commit -m"Fix Issue #32"`
    
    

