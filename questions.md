# Questions

**Q1:** Why you should not return `Null`?

---
**Q2:** When should I use assert and when should I use exception?

---
**Q3:** What you should follow while writing unit tests?

- [ ] Don't write code until you have written a failing unit test.
- [ ] Write code first and write unit tests cover the possible things that can make the code fail. 
- [ ] You cannot write more code than enough to pass the test that is failing.
- [ ] Don't create more tests than necessary to failing.

---
**Q4:**

---
**Q5:** Now, you have finished your tasks about GitHub's issue number 32. 
How to automatically close issue number 32 when you push a commit to GitHub?


# Answers
**A1:** When we return null, we are essentially creating work for ourselves and 
foisting problems upon our callers. If you are not returning null, you do not 
have to check for it and hence your code does not need to follow a different path 
based on the return value. 

    `List<Employee> employees = getEmployees(); 
    if (employees != null) {  
        for(Employee e : employees) {    
            totalPay += e.getPay(); 
        } 
    }`
    
Right now, `getEmployees` can return null, but we change `getEmployee` 
so that it returns an empty list, we can clean up the code to:

    `List<Employee> employees = getEmployees(); 
     for(Employee e : employees) {    
        totalPay += e.getPay(); 
     }`
     
> Ref: Robert C. Martin "The Clean Code" - Donâ€™t Return Null

---
**A2:** Assertions should only be used to verify conditions that should be logically 
impossible to be false (read: sanity checks). These conditions should only be based 
on inputs generated by your own code. Any checks based on external inputs should use exceptions.
        
        A simple rule that I tend to follow is verifying private functions' arguments with asserts, and using exceptions for public/protected functions' arguments.
> Ref: Bil Lewis ["Assertations vs. Exceptions"](http://www.drdobbs.com/jvm/assertations-vs-exceptions/228701655)
---
**A3:**
- [x] Don't write code until you have written a failing unit test.
- [ ] Write code first and write unit tests cover the possible things that can make the code fail. 
- [x] You cannot write more code than enough to pass the test that is failing.
- [x] Don't create more tests than necessary to failing.

The Three Laws of TDD said that

First Law: You may not write production code until you have written a failing unit test.
Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
Third Law: You may not write more production code than is sufficient to pass the currently failing test

> Ref: Robert C. Martin "The Clean Code" - unit tests
---
**A4:**

---
**A5:** `git commit -m"Fix Issue #32"`
    
    

